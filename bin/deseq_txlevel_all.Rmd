---
title: "nanopore iBAT, Illumina reads transcript level, only samples used for ont too"
author: "Christoph Kiefer"
date: "18. September 2019"
output: 
    html_document:
        toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE)
```

```{r library, include=FALSE, cache=FALSE}
library("dplyr")
library("readr")
library("purrr")
library("ggplot2")
library("ggthemes")
library("GGally")
library("cowplot")
library("RColorBrewer")
library("pheatmap")
library("DESeq2")
library("Mus.musculus")
library("vsn")
library("topGO")
library("ReactomePA")
    select <- dplyr::select
    rename <- dplyr::rename
```

# Export of count matrices

Both are normalised using the ratio of medians method. In the rld file, the
variance stabilising transformation described in the DESeq2 paper has been used.

```{r importData, include=FALSE}
# import data
dds <- readRDS(file.path("..", snakemake@input[[1]]))
```

```{r annotateCountMatrices, dependson="importData"}
# prepare countmatrices
rld <- rlog(dds, blind = FALSE)
ntd <- normTransform(dds)

# annotate count matrices
annotate_cm <- function(tibble, keytype = "ENSEMBL") {
    ks <- tibble$gene_id_ens %>% 
        tools::file_path_sans_ext()
    
    sym <- mapIds(org.Mm.eg.db, keys = ks, keytype = keytype,
        column = "SYMBOL", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "mgi_symbol")
    names <- mapIds(org.Mm.eg.db, keys = ks, keytype = keytype,
        column = "GENENAME", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "gene_name")
    
    tibble %>% 
        mutate(gene_id = tools::file_path_sans_ext(gene_id_ens)) %>% 
        left_join(sym, by = "gene_id") %>% 
        left_join(names, by = "gene_id") %>% 
        select(-gene_id) %>% 
        select(gene_id_ens, mgi_symbol, gene_name, everything())
}
```

```{r exportCountMatrices, dependson="annotateCountMatrices", echo=TRUE}
# export count matrices
res_folder <- "../res/txlevel_all" 
dir.create(res_folder, showWarnings = FALSE, recursive = TRUE)

# with variance shrinking
assay(rld) %>%
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    write_csv(file.path(res_folder, "txlevel_all_cm_rld.csv.gz"))

# without
assay(ntd) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    write_csv(file.path(res_folder, "txlevel_all_cm_ntd.csv.gz"))
```

# Quality control

## Sampling depths

Slightly more reads per gene for the cold treatment before normalisation.

```{r samplingDepth1, dependson=c("importData", "annotateCountMatrices")}
# sampling depth, unnormalized
sapply(split(colSums(counts(dds))/1e6, colData(dds)$condition_temp), summary)
```

No difference in the sampling depths after normalisation.

```{r samplingDepth2, dependson=c("importData", "annotateCountMatrices")}
# normalized
assay(rld) %>% 
    as_tibble(rownames = "gene") %>% 
    tidyr::gather("sample", "log2_norm_counts", -gene) %>% 
    ggplot(aes(sample, log2_norm_counts)) +
    geom_boxplot() +
    ylab("log2_norm_counts (rlog transformation)") +
    xlab(NULL)
```

## VSN

The vertical axis in these plots is the square root of the variance over all
samples, including the variance due to the experimental conditions.

(Left side is without transformation, right side after rlog transformation.)

```{r vsn, include = FALSE, dependson="exportCountMatrices"}
vsn1 <- meanSdPlot(assay(ntd))
vsn2 <- meanSdPlot(assay(rld))
```

```{r vsn2, dependson="vsn"}
plot_grid(vsn1$gg + theme(legend.position="none"), vsn2$gg + theme(legend.position="none"))
```

## Sample distances

The samples cluster by temperature, as wanted. Not as clearly as on gene level though.

```{r sampleDist, dependson="annotateCountMatrices"}
# calculate sample distances
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)

# colorscale for the heatmap
colors <- colorRampPalette(rev(brewer.pal(9, "YlOrRd")))(255)

# plot heatmap
pl <- pheatmap(sampleDistMatrix,
         annotation_col = colData(dds) %>%
             as.data.frame() %>%
             select(condition_temp, condition_cage, condition_room, condition_isolation, RIN),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         border_color = NA,
         fontfamily = "Palatino",
         lwd = .2)

pl
```

## Pca on rlog transformed counts

PC1 (31% of the variance) is driven by room/isolation! PC2 (26%) is 
driven by the temperature. Therefore I will adjust for romm as confounding variable.

```{r pca, echo=FALSE}
# calculate pcs
pca <- prcomp(t(assay(rld)), scale. = FALSE)

# importance for labels of the plot
importance <- summary(pca)[[6]]
pca <- as_tibble(pca$x, rownames = "sample") %>%
    left_join(as_tibble(colData(dds), rownames = "sample"), by = "sample")

# plot against room/isolation
# room and isolation are not independent
ggplot(pca, aes(PC1, PC2, colour = condition_temp)) +
    geom_point(aes(pch = condition_room), size = 1.5) +
#    geom_text(aes(label = sample)) +
    stat_ellipse(type = "norm", level = .68) +
    theme_tufte() +
    geom_rangeframe(colour = "black", sides = 'bl') +
    scale_y_continuous(breaks = extended_range_breaks()(pca[, 3]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC2 (%s %% variance)",
                                      round(importance[2,2] * 100, 1))) +
    scale_x_continuous(breaks = extended_range_breaks()(pca[, 2]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC1 (%s %% variance)",
                                      round(importance[2,1] * 100, 1))) +
    scale_color_viridis_d()
```

## Plotmatrix

### Without variance stabilising transformation

```{r plotmatrix1, dependson="exportCountMatrices"}
my_plot <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) +
        geom_point(...) +
        geom_abline(slope = 1, colour = "red")
}

assay(ntd) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

### With variance stabilising transformation

```{r plotmatrix2, dependson = "exportCountMatrices"}
assay(rld) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

Maybe 5034_S33 shows some differences compared to the other samples, like on genelevel?

# Differential transcript expression analysis

```{r adjustConfounders, echo=TRUE, dependson="importData"}
design(dds) <- formula(~ condition_temp + condition_room)
```


```{r runDESeq, dependson="adjustConfounders"}
# set reference
colData(dds)$condition_temp <- relevel(colData(dds)$condition_temp, ref = "22")

# filtering lowly expressed genes and fitting models
dds <- dds[rowSums(counts(dds)) > 10, ] %>% 
    DESeq(., parallel = TRUE)
```

I use lfcThreshold = 1, svalue cutoff = .05 and I shrink the lfc.

```{r results, echo=TRUE, dependson="runDESeq"}
# shrinking log2 fold change
resLFC <- lfcShrink(dds, 
    coef = "condition_temp_4_vs_22",
    lfcThreshold = 1,
    type = "apeglm",
    parallel = TRUE)
```

## Results table

```{r results2, dependson = "results"}
resLFC <- resLFC %>% 
    as_tibble(rownames = "ensembl_transcript_id_version")

summary.resLFC <- function(resLFC, lfcThreshold = 1, svalueCutoff = .05) {
    n_tot <- nrow(resLFC)
    df <- resLFC %>% 
        filter(svalue <= svalueCutoff)
    n_up <- df %>% 
        filter(log2FoldChange > 0) %>% 
        nrow()
    n_down <- df %>% 
        filter(log2FoldChange < 0) %>% 
        nrow()
    cat(sprintf(
"out of %d with nonzero total read count
s-value < %f
LFC > %f (up)    : %d
LFC < -%f (down) : %d",
        n_tot, 
        svalueCutoff,
        lfcThreshold, n_up,
        lfcThreshold, n_down))
}
```


```{r annotation}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl",dataset="mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
    attributes = c("ensembl_transcript_id_version",
        "ensembl_gene_id_version", "mgi_symbol", "description",
        "gene_biotype"), 
    filters = "ensembl_transcript_id_version", 
    values = resLFC$ensembl_transcript_id_version, 
    mart = ensembl)

# calculate average transcript length per gene over all samples
weighted_avgTxLength <- counts(dds, normalized = TRUE) * assays(dds)$avgTxLength
meanOfCounts <- rowMeans(counts(dds, normalized = TRUE))
avgTxLength <- rowMeans(weighted_avgTxLength) %>% 
    `/`(meanOfCounts) %>% 
    tibble::enframe(. ,name = "ensembl_transcript_id_version", value = "avgTxLength")

# get tpm from counts
countToTpm <- function(counts, effLen) {
    rate <- log(counts) - log(effLen)
    denom <- log(sum(exp(rate)))
    exp(rate - denom + log(1e6))
}
```

```{r exportAnnotation, dependson="results2"}
# merge annotation and TPM
resLFC <- resLFC %>% 
    left_join(annotation, by = "ensembl_transcript_id_version") %>% 
    left_join(avgTxLength, by = "ensembl_transcript_id_version") %>% 
    mutate(TPM = countToTpm(baseMean, avgTxLength)) %>% 
    select(ensembl_transcript_id_version, ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, TPM, avgTxLength, log2FoldChange,  lfcSE, svalue)

# export
resLFC %>% 
    arrange(-abs(log2FoldChange)) %>% 
    write_csv(gzfile(file.path(res_folder, "txlevel_all_de.csv.gz")))

# filter and kable
resLFC_signif <- resLFC %>% 
    filter(svalue < .05) %>% 
    arrange(-abs(log2FoldChange))

resLFC_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot, dependson = "runDESeq"}
my_breaks <- function (n = 5, ...) {

    function(x) {
        dings <- .045 * (max(x) - min(x))
        extended_range_breaks_(min(x) + dings , max(x) - dings, n, ...)
    }
}

biotype_groups <- read_csv("../data/biotype_groups.csv") %>% 
    rename(gene_biotype = transcript_biotype)

resLFC %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(svalue < .05, TRUE, FALSE)) %>%
    ggplot(aes(log10(baseMean), log2FoldChange, 
        text = sprintf("%s<br>%s<br>%s", mgi_symbol, ensembl_transcript_id_version, gene_biotype))) +
    geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
    geom_hline(yintercept = 0, colour = "blue") +
#    geom_smooth(colour = "red", method = "auto") +
#    theme_tufte() +
#    geom_rangeframe() +
    scale_y_continuous(breaks = my_breaks(),
        labels = function(x) round(x, 1),
        name = "log2FoldChange ko vs het") +
     scale_x_continuous(breaks = log10(c(1,100,10000,max(resLFC$baseMean))),
        labels = function(x) round(10^x),
        name = "baseMean") +
    scale_color_viridis_d(guide = FALSE)
```

Some tanscripts in the range 10 to 700 counts show a high log2FoldChange. They
might be treated as outliers by the lfc shrinking algoryhtm and therefore not shrunken at all.
It is worth investigating their expression (Maybe only one sample with high expression?).

### Clustering the significantly differentially expressed genes

```{r hclust, dependson = "runDESeq"}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% resLFC_signif$ensembl_transcript_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_temp),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = TRUE,
    lwd = .2,
    cutree_rows = 3,
    border_color = NA)

hclust
```

Two clusters with transcripts clearly regulated by temperature pop up as well as 
one cluster that shows different behaviour in S33 and S34. Those are the samples
with the other room, showing the effect of the confounding variable (that was
accounted for in the analysis).

```{r sampleInfoTable}
colData(dds) %>% 
    as_tibble() %>% 
    select(sample_id, condition_cage, condition_temp, condition_room, RIN) %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```


## Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis, cache=FALSE}
# reference for the GO analysis are all expressed genes
all_genes <- resLFC$ensembl_gene_id_version

get.geneList <- function(signif) {
    gl <- as.factor(as.integer(all_genes %in% signif$ensembl_gene_id_version))
    names(gl) <- all_genes
    # remove version
    names(gl) <- unlist(lapply(stringr::str_split(names(gl), "[.]"), "[[",1))
    gl
}

# function to actually create topGO object
make.topGO <- function(geneList, description) {
    new("topGOdata",
        description = description,
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 10,
        annot = annFUN.org,
        ID = "ensembl",
        mapping = "org.Mm.eg")
}

# conveniance function to get results from topGO
get.results <- function(topGO) {
    topGOres <- runTest(topGO, algorithm = "parentchild", statistic = "fisher")
    GenTable(topGO, p = topGOres, orderBy = "p", ranksOf = "p", topNodes = 10) %>%
        as_tibble() %>%
        mutate(p = as.double(p))
}

# conveniance function to plot the results from topGO
make.plot <-function(results_table, title = '') {
    rf_tibble <- tibble(x = c(1, dim(results_table)[1]),
        y = c(0, max(-log10(results_table$p))))

    results_table %>%
        ggplot(aes(reorder(Term, -log10(p)), -log10(p))) +
        geom_bar(stat = "identity") +
        coord_flip() +
        xlab(NULL) +
        ggtitle(title) +
        geom_rangeframe(aes(x, y), data = rf_tibble, sides = 'bl') +
        scale_y_continuous(breaks = extended_range_breaks()(rf_tibble$y),
            labels = function(x) round(x, 1)) +
        theme_tufte(base_size = 6)
}

# run the analysis
res_go <- resLFC_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
        group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

### Upregulated genes

```{r upGO, cache=FALSE}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Downregulated genes

```{r downGO, cache=FALSE}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

## Reactome

using ReactomePA

reference: all expressed genes

```{r reactome, dependson="runDESeq"}
# annotate with entrez ids
df_reactome <- resLFC_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(resLFC_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- resLFC$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```


```{r plot reactome, fig.width = 12, fig.asp = 0.62, dependson = "reactome"}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

# Session info

```{r sessionInfo}
sessionInfo()
```
