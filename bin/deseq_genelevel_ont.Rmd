---
title: "nanopore iBAT, Illumina reads gene level, only samples used for ont too"
author: "Christoph Kiefer"
date: "18. September 2019"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE)
```

```{r library, include = FALSE, cache = FALSE}
library("DESeq2")
library("dplyr")
library("ggplot2")
library("ggthemes")
library("RColorBrewer")
library("readr")
library("pheatmap")
library("cowplot")
library("purrr")
library("topGO")
    select <- dplyr::select
library("Mus.musculus")
library("ReactomePA")
library("GGally")
library("vsn")
```

```{r importData, include = FALSE}
# import data
dds <- readRDS("../data/dds_gencode.vM22.rds")
```

```{r exportCountMatrices, dependson = c"importData"}
# prepare countmatrices
rld <- rlog(dds, blind = FALSE)
ntd <- normTransform(dds)

# annotate count matrices
annotate_cm <- function(tibble) {
    ks <- tibble$gene_id_ens %>% 
        tools::file_path_sans_ext()
    
    sym <- mapIds(org.Mm.eg.db, keys = ks, keytype = "ENSEMBL",
        column = "SYMBOL", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "mgi_symbol")
    names <- mapIds(org.Mm.eg.db, keys = ks, keytype = "ENSEMBL",
        column = "GENENAME", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "gene_name")
    
    tibble %>% 
        mutate(gene_id = tools::file_path_sans_ext(gene_id_ens)) %>% 
        left_join(sym, by = "gene_id") %>% 
        left_join(names, by = "gene_id") %>% 
        select(-gene_id) %>% 
        select(gene_id_ens, mgi_symbol, gene_name, everything())
}

# export count matrices
dir.create("../res/gencode", showWarnings = FALSE, recursive = TRUE)

# with variance shrinking
assay(rld) %>%
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv("../res/gencode/Gm15441-ko_gencode_cm_rld_koWt.csv.gz")

# without
assay(ntd) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv("../res/gencode/Gm15441-ko_gencode_cm_ntd_koWt.csv.gz")
```

# Quality control

## Sampling depths

```{r samplingDepth, dependson = c("importData", "exportCountMatrices")}
# sampling depth
sapply(split(colSums(counts(dds))/1e6, colData(dds)$condition_genotype), summary)

assay(rld) %>% 
    as_tibble(rownames = "gene") %>% 
    tidyr::gather("sample", "log2_norm_counts", -gene) %>% 
    ggplot(aes(sample, log2_norm_counts)) +
    geom_boxplot()
```

## Sample distances

```{r sampleDist, echo = FALSE, dependson = "exportCountMatrices"}
# calculate sample distances
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)

# colorscale for the heatmap
colors <- colorRampPalette(rev(brewer.pal(9, "YlOrRd")))(255)

# plot heatmap
pl <- pheatmap(sampleDistMatrix,
         annotation_col = colData(dds) %>%
             as.data.frame() %>%
             select(condition_genotype),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         border_color = NA,
         fontfamily = "Palatino",
         lwd = .2)

pl
```

## Pca on rlog transformed counts

```{r pca, dependson = "exportCountMatrices"}
# calculate pcs
pca <- prcomp(t(assay(rld)), scale. = FALSE)

# importance for labels of the plot
importance <- summary(pca)[[6]]
pca <- as_tibble(pca$x, rownames = "sample") %>%
    left_join(as_tibble(colData(dds), rownames = "sample"), by = "sample")

# plot
ggplot(pca, aes(PC1, PC2, colour = condition_genotype)) +
    geom_point(size = 1.5) +
#    stat_ellipse(type = "norm", level = .68) +
    theme_tufte() +
    geom_rangeframe(colour = "black", sides = 'bl') +
    scale_y_continuous(breaks = extended_range_breaks()(pca[, 3]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC2 (%s %% variance)",
                                      round(importance[2,2] * 100, 1))) +
    scale_x_continuous(breaks = extended_range_breaks()(pca[, 2]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC1 (%s %% variance)",
                                      round(importance[2,1] * 100, 1))) +
    scale_color_viridis_d()
```

PCA as well as sample distances do not show clear clustering of the treatment
groups.

## VSN

```{r vsn, echo = TRUE, dependson = "exportCountMatrices"}
meanSdPlot(assay(ntd))
meanSdPlot(assay(rld))
```

## Plotmatrix

### Without variance stabilising transformation

```{r plotmatrix1, dependson = "exportCountMatrices"}
my_plot <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) +
        geom_point(...) +
        geom_abline(slope = 1, colour = "red")
}

assay(ntd) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

### With variance stabilising transformation

```{r plotmatrix2, dependson = "exportCountMatrices"}
assay(rld) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

# Differential gene expression analysis

```{r runDESeq, echo = TRUE, dependson = "importData"}
dds <- dds[rowSums(counts(dds)) > 10,] 

# filter genes with many 0
is.zero <- function(x) x == 0
keep <- counts(dds) %>% 
    apply(., 1, function(x) sum(is.zero(x))) 
keep <- names(keep[keep < 3])    

dds <- dds[keep, ]

dds$condition_genotype <- relevel(dds$condition_genotype, ref = "wt")
dds <- dds %>% 
    DESeq(parallel = TRUE)
```

```{r results, dependson = "runDESeq"}
# creating results table
res <- results(dds,
    name = "condition_genotype_ko_vs_wt",
    lfcThreshold = 1,
    alpha = .05,
    altHypothesis = "greaterAbs",
    parallel = TRUE)

# shrinking log2 fold change
# s value cutoff is set to .005?
resLFC <- lfcShrink(dds, 
    coef = "condition_genotype_ko_vs_wt",
    res = res,
    lfcThreshold = 1,
    type = "apeglm",
    parallel = TRUE)

summary(resLFC)
```

## Results table

```{r resultsTableDescription, dependson = "results"}
mcols(resLFC)$description

resLFC <- resLFC %>% 
    as_tibble(rownames = "ensembl_gene_id_version")
```

```{r annotation}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl",dataset="mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
    attributes = c("ensembl_gene_id_version", "mgi_symbol", "description",
        "gene_biotype"), 
    filters = "ensembl_gene_id_version", 
    values = resLFC$ensembl_gene_id_version, 
    mart = ensembl)

# calculate average transcript length per gene over all samples
weighted_avgTxLength <- counts(dds, normalized = TRUE) * assays(dds)$avgTxLength
meanOfCounts <- rowMeans(counts(dds, normalized = TRUE))
avgTxLength <- rowMeans(weighted_avgTxLength) %>% 
    `/`(meanOfCounts) %>% 
    tibble::enframe(. ,name = "ensembl_gene_id_version", value = "avgTxLength")

# get tpm from counts
countToTpm <- function(counts, effLen) {
    rate <- log(counts) - log(effLen)
    denom <- log(sum(exp(rate)))
    exp(rate - denom + log(1e6))
}
```

```{r exportAnnotation, dependson = "runDESeq"}
# merge annotation and TPM
resLFC <- resLFC %>% 
    left_join(annotation, by = "ensembl_gene_id_version") %>% 
    left_join(avgTxLength, by = "ensembl_gene_id_version") %>% 
    mutate(TPM = countToTpm(baseMean, avgTxLength)) %>% 
    select(ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, TPM, avgTxLength, log2FoldChange,  lfcSE, svalue)

# export
resLFC %>% 
    arrange(-abs(log2FoldChange)) %>% 
    write_csv(gzfile("../res/gencode/Gm15441-ko_gencode_results_koWt.csv.gz"))

# filter and kable
resLFC_signif <- resLFC %>% 
    filter(svalue < .05) %>% 
    arrange(-abs(log2FoldChange))

resLFC_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot, dependson = "runDESeq"}
my_breaks <- function (n = 5, ...) {

    function(x) {
        dings <- .045 * (max(x) - min(x))
        extended_range_breaks_(min(x) + dings , max(x) - dings, n, ...)
    }
}

biotype_groups <- read_csv("../data/biotype_groups.csv") %>% 
    rename(gene_biotype = transcript_biotype)

pl <- resLFC %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(svalue < .05, TRUE, FALSE)) %>%
    ggplot(aes(log10(baseMean), log2FoldChange, 
        text = sprintf("%s<br>%s<br>%s", mgi_symbol, ensembl_gene_id_version, gene_biotype))) +
    geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
    geom_hline(yintercept = 0, colour = "blue") +
    geom_smooth(colour = "red", method = "auto") +
#    theme_tufte() +
#    geom_rangeframe() +
    scale_y_continuous(breaks = my_breaks(),
        labels = function(x) round(x, 1),
        name = "log2FoldChange ko vs het") +
     scale_x_continuous(breaks = log10(c(1,100,10000,max(resLFC$baseMean))),
        labels = function(x) round(10^x),
        name = "baseMean") +
    scale_color_viridis_d(guide = FALSE)

plotly::toWebGL(plotly::ggplotly(pl, tooltip = "text"))
```

### Clustering the significantly differentially expressed genes

```{r hclust, dependson = "runDESeq"}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% resLFC_signif$ensembl_gene_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_genotype),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = FALSE,
    lwd = .2,
    cutree_rows = 2,
    border_color = NA)

hclust
```

## Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis, dependson = "runDESeq"}
# reference for the GO analysis are all expressed genes
all_genes <- resLFC$ensembl_gene_id_version

get.geneList <- function(signif) {
    gl <- as.factor(as.integer(all_genes %in% signif$ensembl_gene_id_version))
    names(gl) <- all_genes
    # remove version
    names(gl) <- unlist(lapply(stringr::str_split(names(gl), "[.]"), "[[",1))
    gl
}

# function to actually create topGO object
make.topGO <- function(geneList, description) {
    new("topGOdata",
        description = description,
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 10,
        annot = annFUN.org,
        ID = "ensembl",
        mapping = "org.Mm.eg")
}

# conveniance function to get results from topGO
get.results <- function(topGO) {
    topGOres <- runTest(topGO, algorithm = "parentchild", statistic = "fisher")
    GenTable(topGO, p = topGOres, orderBy = "p", ranksOf = "p", topNodes = 10) %>%
        as_tibble() %>%
        mutate(p = as.double(p))
}

# conveniance function to plot the results from topGO
make.plot <-function(results_table, title = '') {
    rf_tibble <- tibble(x = c(1, dim(results_table)[1]),
        y = c(0, max(-log10(results_table$p))))

    results_table %>%
        ggplot(aes(reorder(Term, -log10(p)), -log10(p))) +
        geom_bar(stat = "identity") +
        coord_flip() +
        xlab(NULL) +
        ggtitle(title) +
        geom_rangeframe(aes(x, y), data = rf_tibble, sides = 'bl') +
        scale_y_continuous(breaks = extended_range_breaks()(rf_tibble$y),
            labels = function(x) round(x, 1)) +
        theme_tufte(base_size = 6)
}

# run the analysis
res_go <- resLFC_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
        group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

### Upregulated genes

```{r upGO, dependson = "goAnalysis"}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Downregulated genes

```{r downGO, dependson = "goAnalysis"}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

## Reactome

using ReactomePA

reference: all expressed genes

```{r reactome, dependson = "runDESeq"}
# annotate with entrez ids
df_reactome <- resLFC_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(resLFC_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- resLFC$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```


```{r plot reactome, fig.width = 12, fig.asp = 0.62, dependson = "reactome"}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

# Session info

```{r sessionInfo}
sessionInfo()
```

