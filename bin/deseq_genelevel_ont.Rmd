---
title: "nanopore iBAT, Illumina reads gene level, only samples used for ont too"
author: "Christoph Kiefer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document:
        toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE)
source("packrat/init.R")
```

```{r library, include=FALSE}
library("dplyr")
library("readr")
library("purrr")
library("ggplot2")
library("ggthemes")
library("GGally")
library("cowplot")
library("RColorBrewer")
library("pheatmap")
library("DESeq2")
library("Mus.musculus")
library("vsn")
library("topGO")
    select <- dplyr::select
    rename <- dplyr::rename
library("ReactomePA")
BPPARAM = BiocParallel::MulticoreParam(snakemake@threads[[1]])
```

# Export of count matrices

There are multiple countmatrices to be found in the res/ folder. 

* rld: log2 level, between sample normalised, variance stabilised. See regularized log (rlog) transformation 
[http://dx.doi.org/10.1186/s13059-014-0550-8]. This is the main table for any plotting and correlation analyses etc.

* ntd: log2 level, between sample normalised. For genes, that are not expressed in a condition, the rlog transformed 
values will not be 0, which might be confusing sometimes. Therfore I add this table.

* tpm: between sample normalised and within sample (between genes) normalised.

* cts: raw counts, count output from tximport as imported from salmon estimated
counts: no normalisation at all. This one should be used for statistical
analyses in DESeq or EdgeR.

In the data/ folder, there is also the DESeq data set object (dds), that can be imported into R
using readRDS() to be directly analysed.

```{r importData, include=FALSE}
# import data
dds <- readRDS(snakemake@input[[1]])
```

```{r annotateCountMatrices}
# prepare countmatrices
rld <- rlog(dds, blind = FALSE)
ntd <- normTransform(dds)

# https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/
fpkmToTpm <- function(fpkm) {
    exp(log(fpkm) - log(sum(fpkm)) + log(1e6))
}

tpm <- fpkm(dds, robust = TRUE)
tpm <- apply(tpm, 2, fpkmToTpm)

# annotate count matrices
annotate_cm <- function(tibble) {
    ks <- tibble$gene_id_ens %>% 
        tools::file_path_sans_ext()
    
    sym <- mapIds(org.Mm.eg.db, keys = ks, keytype = "ENSEMBL",
        column = "SYMBOL", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "mgi_symbol")
    names <- mapIds(org.Mm.eg.db, keys = ks, keytype = "ENSEMBL",
        column = "GENENAME", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "gene_name")
    
    tibble %>% 
        mutate(gene_id = tools::file_path_sans_ext(gene_id_ens)) %>% 
        left_join(sym, by = "gene_id") %>% 
        left_join(names, by = "gene_id") %>% 
        select(-gene_id) %>% 
        select(gene_id_ens, mgi_symbol, gene_name, everything())
}
```

```{r exportCountMatrices}
# export count matrices
res_folder <- snakemake@params[["out_folder"]]
dir.create(res_folder, showWarnings = FALSE, recursive = TRUE)

# with variance shrinking
assay(rld) %>%
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv(file.path(res_folder, "genelevel_ont_cm_rld.csv.gz"))

# without
assay(ntd) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv(file.path(res_folder, "genelevel_ont_cm_ntd.csv.gz"))

# tpm
tpm %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv(file.path(res_folder, "genelevel_ont_cm_tpm.csv.gz"))

# raw counts
counts(dds, normalized = FALSE) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm() %>% 
    write_csv(file.path(res_folder, "genelevel_ont_cm_cts.csv.gz"))
```

# Quality control

## Sampling depths

Slightly more reads per gene for the cold treatment before normalisation.

```{r samplingDepth1}
# sampling depth, unnormalized
sapply(split(colSums(counts(dds))/1e6, colData(dds)$condition_temp), summary)
```

No difference in the sampling depths after normalisation.

```{r samplingDepth2}
# normalized
assay(rld) %>% 
    as_tibble(rownames = "gene") %>% 
    tidyr::gather("sample", "log2_norm_counts", -gene) %>% 
    ggplot(aes(sample, log2_norm_counts)) +
    geom_boxplot() +
    ylab("log2_norm_counts (rlog transformation)") +
    xlab(NULL)
```

## VSN

The vertical axis in such plots is the square root of the variance over all
samples, including the variance due to the experimental conditions.

(Left side is without transformation, right side after rlog transformation.)

```{r vsn, include = FALSE}
vsn1 <- meanSdPlot(assay(ntd))
vsn2 <- meanSdPlot(assay(rld))
```

```{r vsn2}
plot_grid(vsn1$gg + theme(legend.position="none"), vsn2$gg + theme(legend.position="none"))
```

## Sample distances

The samples cluster by temperature, as wanted.

```{r sampleDist}
# calculate sample distances
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)

# colorscale for the heatmap
colors <- colorRampPalette(rev(brewer.pal(9, "YlOrRd")))(255)

# plot heatmap
pl <- pheatmap(sampleDistMatrix,
         annotation_col = colData(dds) %>%
             as.data.frame() %>%
             select(condition_temp, condition_cage, condition_room, condition_isolation, RIN),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         border_color = NA,
         fontfamily = "Palatino",
         lwd = .2)

pl
```

## Pca on rlog transformed counts

PC1 (50% of the variance) is driven by the temperature. Assumably PC2 (26%) is 
driven by the room/RNA isolation (see analysis of all samples). I will not adjust
for confounders in this analysis.

```{r pca, echo=FALSE}
# calculate pcs
pca <- prcomp(t(assay(rld)), scale. = FALSE)

# importance for labels of the plot
importance <- summary(pca)[[6]]
pca <- as_tibble(pca$x, rownames = "sample") %>%
    left_join(as_tibble(colData(dds), rownames = "sample"), by = "sample")

# plot against room/isolation
# room and isolation are not independent
ggplot(pca, aes(PC1, PC2, colour = condition_temp)) +
    geom_point(aes(pch = condition_room), size = 1.5) +
#    geom_text(aes(label = sample)) +
    stat_ellipse(type = "norm", level = .68) +
    theme_tufte() +
    geom_rangeframe(colour = "black", sides = 'bl') +
    scale_y_continuous(breaks = extended_range_breaks()(pca[, 3]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC2 (%s %% variance)",
                                      round(importance[2,2] * 100, 1))) +
    scale_x_continuous(breaks = extended_range_breaks()(pca[, 2]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC1 (%s %% variance)",
                                      round(importance[2,1] * 100, 1))) +
    scale_color_viridis_d()
```

## Plotmatrix

### Without variance stabilising transformation

```{r plotmatrix1}
my_plot <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) +
        geom_point(...) +
        geom_abline(slope = 1, colour = "red")
}

assay(ntd) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

### With variance stabilising transformation

```{r plotmatrix2}
assay(rld) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

Maybe 5034_S33 shows some differences compared to the other samples?

# Differential gene expression analysis

## Filtering and adjusting for confounders

```{r runDESeq, echo=TRUE}
# set reference
colData(dds)$condition_temp <- relevel(colData(dds)$condition_temp, ref = "22")

# filtering lowly expressed genes and fitting models
dds <- dds[rowSums(counts(dds)) > 10, ] %>% 
    DESeq(., parallel = TRUE, BPPARAM = BPPARAM)
```

## Results using lfc shrinkage

I use lfcThreshold = 1, svalue cutoff = .05 and I shrink the lfc.

```{r results, echo=TRUE}
# shrinking log2 fold change
resLFC <- lfcShrink(dds, 
    coef = "condition_temp_4_vs_22",
    lfcThreshold = 1,
    type = "apeglm",
    parallel = TRUE,
    BPPARAM = BPPARAM)
```

### Results table

```{r results2}
resLFC <- resLFC %>% 
    as_tibble(rownames = "ensembl_gene_id_version")

summary.resLFC <- function(resLFC, lfcThreshold = 1, svalueCutoff = .05) {
    n_tot <- nrow(resLFC)
    df <- resLFC %>% 
        filter(svalue <= svalueCutoff)
    n_up <- df %>% 
        filter(log2FoldChange > 0) %>% 
        nrow()
    n_down <- df %>% 
        filter(log2FoldChange < 0) %>% 
        nrow()
    cat(sprintf(
"out of %d with nonzero total read count
s-value < %f
LFC > %f (up)    : %d
LFC < -%f (down) : %d",
        n_tot, 
        svalueCutoff,
        lfcThreshold, n_up,
        lfcThreshold, n_down))
}

summary.resLFC(resLFC)
```

```{r annotation}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl", dataset = "mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
        attributes = c("ensembl_gene_id_version", "mgi_symbol", "description",
            "gene_biotype"), 
        filters = "ensembl_gene_id_version", 
        values = unique(resLFC$ensembl_gene_id_version), 
        mart = ensembl) %>% 
    as_tibble() %>% 
    distinct(ensembl_gene_id_version, .keep_all = TRUE)

baseTPM <- rowMeans(tpm) %>% 
    tibble::enframe(name = "ensembl_gene_id_version",
        value = "baseTPM")
```

```{r exportAnnotation}
# merge annotation and TPM
resLFC <- resLFC %>% 
    left_join(annotation, by = "ensembl_gene_id_version") %>% 
    left_join(baseTPM, by = "ensembl_gene_id_version") %>% 
    select(ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, baseTPM, log2FoldChange,  lfcSE, svalue)

# export
resLFC %>% 
    arrange(-abs(log2FoldChange)) %>% 
    write_csv(gzfile(file.path(res_folder, "genelevel_ont_de.csv.gz")))

# filter and kable
resLFC_signif <- resLFC %>% 
    filter(svalue < .05) %>% 
    arrange(-abs(log2FoldChange))

resLFC_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot}
my_breaks <- function (n = 5, ...) {

    function(x) {
        dings <- .045 * (max(x) - min(x))
        extended_range_breaks_(min(x) + dings , max(x) - dings, n, ...)
    }
}

biotype_groups <- read_csv(snakemake@input[[2]]) %>% 
    rename(gene_biotype = transcript_biotype)

resLFC %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(svalue < .05, TRUE, FALSE)) %>%
    ggplot(aes(log10(baseMean), log2FoldChange, 
        text = sprintf("%s<br>%s<br>%s", mgi_symbol, ensembl_gene_id_version, gene_biotype))) +
    geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
    geom_hline(yintercept = 0, colour = "blue") +
    scale_y_continuous(breaks = my_breaks(),
        labels = function(x) round(x, 1),
        name = "log2FoldChange ko vs het") +
     scale_x_continuous(breaks = log10(c(1,100,10000,max(resLFC$baseMean))),
        labels = function(x) round(10^x),
        name = "baseMean") +
    scale_color_viridis_d(guide = FALSE)
```

### Clustering the significantly differentially expressed genes

```{r hclust}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% resLFC_signif$ensembl_gene_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_temp),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = FALSE,
    lwd = .2,
    cutree_rows = 2,
    border_color = NA)

hclust
```

### Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis}
# reference for the GO analysis are all expressed genes
all_genes <- resLFC$ensembl_gene_id_version

get.geneList <- function(signif) {
    gl <- as.factor(as.integer(all_genes %in% signif$ensembl_gene_id_version))
    names(gl) <- all_genes
    # remove version
    names(gl) <- unlist(lapply(stringr::str_split(names(gl), "[.]"), "[[",1))
    gl
}

# function to actually create topGO object
make.topGO <- function(geneList, description) {
    new("topGOdata",
        description = description,
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 10,
        annot = annFUN.org,
        ID = "ensembl",
        mapping = "org.Mm.eg")
}

# conveniance function to get results from topGO
get.results <- function(topGO) {
    topGOres <- runTest(topGO, algorithm = "parentchild", statistic = "fisher")
    GenTable(topGO, p = topGOres, orderBy = "p", ranksOf = "p", topNodes = 10) %>%
        as_tibble() %>%
        mutate(p = as.double(p))
}

# conveniance function to plot the results from topGO
make.plot <-function(results_table, title = '') {
    rf_tibble <- tibble(x = c(1, dim(results_table)[1]),
        y = c(0, max(-log10(results_table$p))))

    results_table %>%
        ggplot(aes(reorder(Term, -log10(p)), -log10(p))) +
        geom_bar(stat = "identity") +
        coord_flip() +
        xlab(NULL) +
        ggtitle(title) +
        geom_rangeframe(aes(x, y), data = rf_tibble, sides = 'bl') +
        scale_y_continuous(breaks = extended_range_breaks()(rf_tibble$y),
            labels = function(x) round(x, 1)) +
        theme_tufte(base_size = 6)
}

# run the analysis
res_go <- resLFC_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
    group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

#### Upregulated genes

```{r upGO}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

#### Downregulated genes

```{r downGO}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Reactome

using ReactomePA

reference: all expressed genes

```{r reactome}
# annotate with entrez ids
df_reactome <- resLFC_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(resLFC_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- resLFC$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```

```{r plot_reactome, fig.width = 12, fig.asp = 0.62}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

## Results without shrinking

```{r results_noshrink, echo=TRUE}
res <- results(dds, 
    contrast = c("condition_temp", "4", "22"),
    parallel = TRUE)
```

### Results table

```{r results2_noshrink}
res <- res %>% 
    as_tibble(rownames = "ensembl_gene_id_version")

summary.res <- function(res, lfcThreshold = 0, pvalueCutoff = .05) {
    n_tot <- nrow(res)
    df <- res %>% 
        filter(padj <= pvalueCutoff)
    n_up <- df %>% 
        filter(log2FoldChange > 0) %>% 
        nrow()
    n_down <- df %>% 
        filter(log2FoldChange < 0) %>% 
        nrow()
    cat(sprintf(
"out of %d with nonzero total read count
padj < %f
LFC > %f (up)    : %d
LFC < -%f (down) : %d",
        n_tot, 
        pvalueCutoff,
        lfcThreshold, n_up,
        lfcThreshold, n_down))
}

summary.res(res)
```

```{r annotation_noshrink}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl", dataset = "mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
        attributes = c("ensembl_gene_id_version", "mgi_symbol", "description",
            "gene_biotype"), 
        filters = "ensembl_gene_id_version", 
        values = res$ensembl_gene_id_version, 
        mart = ensembl) %>% 
    as_tibble() %>% 
    distinct(ensembl_gene_id_version, .keep_all = TRUE)

baseTPM <- rowMeans(tpm) %>% 
    tibble::enframe(name = "ensembl_gene_id_version",
        value = "baseTPM")
```

```{r exportAnnotation_noshrink}
# merge annotation and TPM
res <- res %>% 
    left_join(annotation, by = "ensembl_gene_id_version") %>% 
    left_join(baseTPM, by = "ensembl_gene_id_version") %>% 
    select(ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, baseTPM, log2FoldChange,  lfcSE, pvalue, padj)

# filter and kable
res_signif <- res %>% 
    filter(padj < .05) %>% 
    arrange(-abs(log2FoldChange))

res_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot_noshrink}
res %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(padj < .05, TRUE, FALSE)) %>%
    ggplot(aes(log10(baseMean), log2FoldChange, 
        text = sprintf("%s<br>%s<br>%s", mgi_symbol, ensembl_gene_id_version, gene_biotype))) +
    geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
    geom_hline(yintercept = 0, colour = "blue") +
    scale_y_continuous(breaks = my_breaks(),
        labels = function(x) round(x, 1),
        name = "log2FoldChange ko vs het") +
     scale_x_continuous(breaks = log10(c(1,100,10000,max(res$baseMean))),
        labels = function(x) round(10^x),
        name = "baseMean") +
    scale_color_viridis_d(guide = FALSE)
```

### Clustering the significantly differentially expressed genes

```{r hclust_noshrink}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% res_signif$ensembl_gene_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_temp),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = FALSE,
    lwd = .2,
    cutree_rows = 2,
    border_color = NA)

hclust
```

### Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis_noshrink}
# reference for the GO analysis are all expressed genes
all_genes <- res$ensembl_gene_id_version

get.geneList <- function(signif) {
    gl <- as.factor(as.integer(all_genes %in% signif$ensembl_gene_id_version))
    names(gl) <- all_genes
    # remove version
    names(gl) <- unlist(lapply(stringr::str_split(names(gl), "[.]"), "[[",1))
    gl
}

# function to actually create topGO object
make.topGO <- function(geneList, description) {
    new("topGOdata",
        description = description,
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 10,
        annot = annFUN.org,
        ID = "ensembl",
        mapping = "org.Mm.eg")
}

# conveniance function to get results from topGO
get.results <- function(topGO) {
    topGOres <- runTest(topGO, algorithm = "parentchild", statistic = "fisher")
    GenTable(topGO, p = topGOres, orderBy = "p", ranksOf = "p", topNodes = 10) %>%
        as_tibble() %>%
        mutate(p = as.double(p))
}

# conveniance function to plot the results from topGO
make.plot <-function(results_table, title = '') {
    rf_tibble <- tibble(x = c(1, dim(results_table)[1]),
        y = c(0, max(-log10(results_table$p))))

    results_table %>%
        ggplot(aes(reorder(Term, -log10(p)), -log10(p))) +
        geom_bar(stat = "identity") +
        coord_flip() +
        xlab(NULL) +
        ggtitle(title) +
        geom_rangeframe(aes(x, y), data = rf_tibble, sides = 'bl') +
        scale_y_continuous(breaks = extended_range_breaks()(rf_tibble$y),
            labels = function(x) round(x, 1)) +
        theme_tufte(base_size = 6)
}

# run the analysis
res_go <- res_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
    group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

#### Upregulated genes

```{r upGO_noshrink}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

#### Downregulated genes

```{r downGO_noshrink}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Reactome

using ReactomePA

reference: all expressed genes

```{r reactome_noshrink}
# annotate with entrez ids
df_reactome <- res_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(res_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- res$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```

```{r plot reactome_noshrink, fig.width = 12, fig.asp = 0.62}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

# Session info

```{r sessionInfo}
sessionInfo()
```
