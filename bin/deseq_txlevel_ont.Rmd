---
title: "nanopore iBAT, Illumina reads transcript level, only samples used for ont too"
author: "Christoph Kiefer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document:
        toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE)
source("packrat/init.R")
```

```{r library, include=FALSE}
library("dplyr")
library("readr")
library("purrr")
library("ggplot2")
library("ggiraph")
library("ggthemes")
library("GGally")
library("cowplot")
library("RColorBrewer")
library("pheatmap")
library("DESeq2")
library("Mus.musculus")
library("vsn")
library("topGO")
library("ReactomePA")
    select <- dplyr::select
    rename <- dplyr::rename
BPPARAM <- BiocParallel::MulticoreParam(snakemake@threads[[1]])
```

# Export of count matrices

There are multiple countmatrices to be found in the res/ folder. 

* rld: log2 level, between sample normalised, variance stabilised. See regularized log (rlog) transformation 
[http://dx.doi.org/10.1186/s13059-014-0550-8]. This is the main table for any plotting and correlation analyses etc.

* ntd: log2 level, between sample normalised. For genes, that are not expressed in a condition, the rlog transformed 
values will not be 0, which might be confusing sometimes. Therfore I add this table.

* tpm: between sample normalised and within sample (between genes) normalised.

* cts: raw counts, count output from tximport as imported from salmon estimated
counts: no normalisation at all. This one should be used for statistical
analyses in DESeq or EdgeR.

In the data/ folder, there is also the DESeq data set object (dds), that can be imported into R
using readRDS() to be directly analysed.

```{r importData, include=FALSE}
# import data
dds <- readRDS(snakemake@input[[1]])
```

```{r annotateCountMatrices}
# prepare countmatrices
rld <- rlog(dds, blind = FALSE)
ntd <- normTransform(dds)

# https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/
fpkmToTpm <- function(fpkm) {
    exp(log(fpkm) - log(sum(fpkm)) + log(1e6))
}

tpm <- fpkm(dds, robust = TRUE)
tpm <- apply(tpm, 2, fpkmToTpm)

# annotate count matrices
annotate_cm <- function(tibble, keytype = "ENSEMBL") {
    ks <- tibble$gene_id_ens %>% 
        tools::file_path_sans_ext()
    
    sym <- mapIds(org.Mm.eg.db, keys = ks, keytype = keytype,
        column = "SYMBOL", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "mgi_symbol")
    names <- mapIds(org.Mm.eg.db, keys = ks, keytype = keytype,
        column = "GENENAME", multiVals = "first") %>% 
        tibble::enframe(name = "gene_id", value = "gene_name")
    
    tibble %>% 
        mutate(gene_id = tools::file_path_sans_ext(gene_id_ens)) %>% 
        left_join(sym, by = "gene_id") %>% 
        left_join(names, by = "gene_id") %>% 
        select(-gene_id) %>% 
        select(gene_id_ens, mgi_symbol, gene_name, everything())
}
```

```{r exportCountMatrices}
# export count matrices
res_folder <- snakemake@params[["out_folder"]]
dir.create(res_folder, showWarnings = FALSE, recursive = TRUE)

# with variance shrinking
assay(rld) %>%
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    rename(transcript_id_ens = "gene_id_ens") %>% 
    write_csv(file.path(res_folder, "txlevel_ont_cm_rld.csv.gz"))

# without
assay(ntd) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    rename(transcript_id_ens = "gene_id_ens") %>%
    write_csv(file.path(res_folder, "txlevel_ont_cm_ntd.csv.gz"))

tpm %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    rename(transcript_id_ens = "gene_id_ens") %>% 
    write_csv(file.path(res_folder, "txlevel_ont_cm_tpm.csv.gz"))

counts(dds, normalized = FALSE) %>% 
    as_tibble(rownames = "gene_id_ens") %>% 
    annotate_cm(keytype = "ENSEMBLTRANS") %>% 
    write_csv(file.path(res_folder, "txlevel_ont_cm_cts.csv.gz"))
```

# Quality control

## Sampling depths

Slightly more reads per gene for the cold treatment before normalisation.

```{r samplingDepth1}
# sampling depth, unnormalized
sapply(split(colSums(counts(dds))/1e6, colData(dds)$condition_temp), summary)
```

No difference in the sampling depths after normalisation.

```{r samplingDepth2}
# normalized
assay(rld) %>% 
    as_tibble(rownames = "gene") %>% 
    tidyr::gather("sample", "log2_norm_counts", -gene) %>% 
    ggplot(aes(sample, log2_norm_counts)) +
    geom_boxplot() +
    ylab("log2_norm_counts (rlog transformation)") +
    xlab(NULL)
```

## VSN

The vertical axis in these plots is the square root of the variance over all
samples, including the variance due to the experimental conditions.

(Left side is without transformation, right side after rlog transformation.)

```{r vsn, include = FALSE}
vsn1 <- meanSdPlot(assay(ntd))
vsn2 <- meanSdPlot(assay(rld))
```

```{r vsn2}
plot_grid(vsn1$gg + theme(legend.position="none"), vsn2$gg + theme(legend.position="none"))
```

## Sample distances

The samples cluster by temperature, as wanted. Not as clearly as on gene level though.

```{r sampleDist}
# calculate sample distances
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix(sampleDists)

# colorscale for the heatmap
colors <- colorRampPalette(rev(brewer.pal(9, "YlOrRd")))(255)

# plot heatmap
pl <- pheatmap(sampleDistMatrix,
         annotation_col = colData(dds) %>%
             as.data.frame() %>%
             select(condition_temp, condition_cage, condition_room, condition_isolation, RIN),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         border_color = NA,
         fontfamily = "Palatino",
         lwd = .2)

pl
```

## Pca on rlog transformed counts

PC1 (31% of the variance) is driven by room/isolation! PC2 (26%) is 
driven by the temperature. Therefore I will adjust for romm as confounding variable.

```{r pca, echo=FALSE}
# calculate pcs
pca <- prcomp(t(assay(rld)), scale. = FALSE)

# importance for labels of the plot
importance <- summary(pca)[[6]]
pca <- as_tibble(pca$x, rownames = "sample") %>%
    left_join(as_tibble(colData(dds), rownames = "sample"), by = "sample")

# plot against room/isolation
# room and isolation are not independent
pca_pl <- ggplot(pca, aes(PC1, PC2, colour = condition_temp)) +
    geom_point_interactive(aes(pch = condition_room, 
        tooltip = sprintf("%s<br>cage = %s", sample, condition_cage),
        data_id = condition_cage), size = 2) +
    stat_ellipse(type = "norm", level = .68) +
    theme_tufte() +
    geom_rangeframe(colour = "black", sides = 'bl') +
    scale_y_continuous(breaks = extended_range_breaks()(pca[, 3]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC2 (%s %% variance)",
                                      round(importance[2,2] * 100, 1))) +
    scale_x_continuous(breaks = extended_range_breaks()(pca[, 2]),
                       labels = function(x) round(x, 1),
                       name = sprintf("PC1 (%s %% variance)",
                                      round(importance[2,1] * 100, 1))) +
    scale_color_viridis_d()

girafe(code = print(pca_pl))
```

## Plotmatrix

### Without variance stabilising transformation

```{r plotmatrix1}
my_plot <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) +
        geom_point(...) +
        geom_abline(slope = 1, colour = "red")
}

assay(ntd) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

### With variance stabilising transformation

```{r plotmatrix2}
assay(rld) %>%
    as_tibble() %>% 
    filter(rowSums(.) > 3) %>% 
    mutate_all(as.double) %>% 
    ggpairs(lower = list(continuous = my_plot))
```

Maybe 5034_S33 shows some differences compared to the other samples, like on genelevel?

# Differential transcript expression analysis

## Filtering and adjusting for confounders


```{r adjustConfounders, echo=TRUE}
design(dds) <- formula(~ condition_temp + condition_room)
```

```{r runDESeq, echo = TRUE}
# set reference
colData(dds)$condition_temp <- relevel(colData(dds)$condition_temp, ref = "22")

# filtering lowly expressed genes and fitting models
dds <- dds[rowSums(counts(dds)) > 10, ] %>% 
    DESeq(., parallel = TRUE, BPPARAM = BPPARAM)
```

## Results using lfc shrinkage

I use lfcThreshold = 1, svalue cutoff = .05 and I shrink the lfc using apeglm.

```{r results, echo=TRUE}
# shrinking log2 fold change
resLFC <- lfcShrink(dds, 
    coef = "condition_temp_4_vs_22",
    lfcThreshold = 1,
    type = "apeglm",
    parallel = TRUE, BPPARAM = BPPARAM)
```

### Results table

```{r results2}
resLFC <- resLFC %>% 
    as_tibble(rownames = "ensembl_transcript_id_version")

summary.resLFC <- function(resLFC, lfcThreshold = 1, svalueCutoff = .05) {
    n_tot <- nrow(resLFC)
    df <- resLFC %>% 
        filter(svalue <= svalueCutoff)
    n_up <- df %>% 
        filter(log2FoldChange > 0) %>% 
        nrow()
    n_down <- df %>% 
        filter(log2FoldChange < 0) %>% 
        nrow()
    cat(sprintf(
"out of %d with nonzero total read count
s-value < %f
LFC > %f (up)    : %d
LFC < -%f (down) : %d",
        n_tot, 
        svalueCutoff,
        lfcThreshold, n_up,
        lfcThreshold, n_down))
}

summary.resLFC(resLFC)
```

```{r annotation}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl", dataset = "mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
        attributes = c("ensembl_transcript_id_version",
            "ensembl_gene_id_version", "mgi_symbol", "description",
            "gene_biotype", "transcript_length"), 
        filters = "ensembl_transcript_id_version", 
        values = unique(resLFC$ensembl_transcript_id_version), 
        mart = ensembl) %>% 
    as_tibble() %>% 
    distinct(ensembl_transcript_id_version, .keep_all = TRUE)

baseTPM <- rowMeans(tpm) %>% 
    tibble::enframe(name = "ensembl_transcript_id_version",
        value = "baseTPM")
```

```{r exportAnnotation}
# merge annotation and TPM
resLFC <- resLFC %>% 
    left_join(annotation, by = "ensembl_transcript_id_version") %>% 
    left_join(baseTPM, by = "ensembl_transcript_id_version") %>% 
    select(ensembl_transcript_id_version, ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, baseTPM, transcript_length, log2FoldChange,  lfcSE, svalue)

# export
resLFC %>% 
    arrange(-abs(log2FoldChange)) %>% 
    write_csv(gzfile(file.path(res_folder, "txlevel_ont_de.csv.gz")))

# filter and kable
resLFC_signif <- resLFC %>% 
    filter(svalue < .05) %>% 
    arrange(-abs(log2FoldChange))

resLFC_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot}
my_breaks <- function (n = 5, ...) {

    function(x) {
        dings <- .045 * (max(x) - min(x))
        extended_range_breaks_(min(x) + dings , max(x) - dings, n, ...)
    }
}

biotype_groups <- read_csv(snakemake@input[[2]]) %>% 
    rename(gene_biotype = transcript_biotype)

resLFC %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(svalue < .05, TRUE, FALSE)) %>%
    ggplot(aes(log10(baseMean), log2FoldChange, 
        text = sprintf("%s<br>%s<br>%s", mgi_symbol, ensembl_transcript_id_version, gene_biotype))) +
    geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
    geom_hline(yintercept = 0, colour = "blue") +
#    geom_smooth(colour = "red", method = "auto") +
#    theme_tufte() +
#    geom_rangeframe() +
    scale_y_continuous(breaks = my_breaks(),
        labels = function(x) round(x, 1),
        name = "log2FoldChange ko vs het") +
     scale_x_continuous(breaks = log10(c(1,100,10000,max(resLFC$baseMean))),
        labels = function(x) round(10^x),
        name = "baseMean") +
    scale_color_viridis_d(guide = FALSE)
```

Some tanscripts in the range 10 to 700 counts show a high log2FoldChange. They
might be treated as outliers by the lfc shrinking algoryhtm and therefore not shrunken at all.
It is worth investigating their expression (Maybe only one sample with high expression?).

```{r outliers}
order <- colData(dds) %>%
    as_tibble(rownames = "sample") %>%
    dplyr::arrange(condition_temp) %>% 
    pull(sample)

pl <- resLFC %>% 
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(svalue < .05, TRUE, FALSE)) %>% 
    filter(complete.cases(.)) %>% 
    filter(abs(log2FoldChange) > 6) %>% 
    select(ensembl_transcript_id_version, ensembl_gene_id_version, mgi_symbol,
       grouped_biotype, baseMean, baseTPM) %>% 
    left_join(counts(dds) %>% as_tibble(rownames = "ensembl_transcript_id_version"),
        by = "ensembl_transcript_id_version") %>% 
    tidyr::gather(key = "sample", value = "counts" ,
        -ensembl_transcript_id_version, - ensembl_gene_id_version, 
        -mgi_symbol, - grouped_biotype, -baseMean, -baseTPM) %>% 
    mutate(sample = factor(sample, levels = order)) %>% 
    ggplot(., aes(sample, ensembl_transcript_id_version)) +
        geom_tile_interactive(aes(fill = log10(counts), 
            tooltip = sprintf("%s<br>base Mean = %s<br>average TPM = %s", mgi_symbol, round(baseMean, 1), round(baseTPM, 2)), 
            onclick = sprintf("http://www.ensembl.org/Mus_musculus/Gene/Summary?db=core;g=%s", ensembl_gene_id_version))) +
    scale_fill_viridis_c()
    
girafe(ggobj =  pl)
```

### Clustering the significantly differentially expressed genes

```{r hclust}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% resLFC_signif$ensembl_transcript_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_temp),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = TRUE,
    lwd = .2,
    cutree_rows = 3,
    border_color = NA)

hclust
```

Two clusters with transcripts clearly regulated by temperature pop up as well as 
one cluster that shows different behaviour in S33 and S34. Those are the samples
with the other room, showing the effect of the confounding variable (that was
accounted for in the analysis).

```{r sampleInfoTable}
colData(dds) %>% 
    as_tibble() %>% 
    select(sample_id, condition_cage, condition_temp, condition_room, RIN) %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```


### Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis}
# reference for the GO analysis are all expressed genes
all_genes <- resLFC$ensembl_gene_id_version

get.geneList <- function(signif) {
    gl <- as.factor(as.integer(all_genes %in% signif$ensembl_gene_id_version))
    names(gl) <- all_genes
    # remove version
    names(gl) <- unlist(lapply(stringr::str_split(names(gl), "[.]"), "[[",1))
    gl
}

# function to actually create topGO object
make.topGO <- function(geneList, description) {
    new("topGOdata",
        description = description,
        ontology = "BP",
        allGenes = geneList,
        nodeSize = 10,
        annot = annFUN.org,
        ID = "ensembl",
        mapping = "org.Mm.eg")
}

# conveniance function to get results from topGO
get.results <- function(topGO) {
    topGOres <- runTest(topGO, algorithm = "parentchild", statistic = "fisher")
    GenTable(topGO, p = topGOres, orderBy = "p", ranksOf = "p", topNodes = 10) %>%
        as_tibble() %>%
        mutate(p = as.double(p))
}

# conveniance function to plot the results from topGO
make.plot <-function(results_table, title = '') {
    rf_tibble <- tibble(x = c(1, dim(results_table)[1]),
        y = c(0, max(-log10(results_table$p))))

    results_table %>%
        ggplot(aes(reorder(Term, -log10(p)), -log10(p))) +
        geom_bar(stat = "identity") +
        coord_flip() +
        xlab(NULL) +
        ggtitle(title) +
        geom_rangeframe(aes(x, y), data = rf_tibble, sides = 'bl') +
        scale_y_continuous(breaks = extended_range_breaks()(rf_tibble$y),
            labels = function(x) round(x, 1)) +
        theme_tufte(base_size = 6)
}

# run the analysis
res_go <- resLFC_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
        group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

#### Upregulated genes

```{r upGO}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

#### Downregulated genes

```{r downGO}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Reactome

using ReactomePA

reference: all expressed genes

```{r reactome}
# annotate with entrez ids
df_reactome <- resLFC_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(resLFC_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- resLFC$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```


```{r plot reactome, fig.width = 12, fig.asp = 0.62}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

## Results without shrinking

```{r results_noShrink, echo=TRUE}
# shrinking log2 fold change
res <- results(dds, 
    contrast = c("condition_temp", "4", "22"),
    parallel = TRUE, BPPARAM = BPPARAM)
```

### Results table

```{r results_noshrink_summary}
res <- res %>% 
    as_tibble(rownames = "ensembl_transcript_id_version")

summary.res <- function(res, lfcThreshold = 0, pvalueCutoff = .05) {
    n_tot <- nrow(res)
    df <- res %>% 
        filter(padj <= pvalueCutoff)
    n_up <- df %>% 
        filter(log2FoldChange > 0) %>% 
        nrow()
    n_down <- df %>% 
        filter(log2FoldChange < 0) %>% 
        nrow()
    cat(sprintf(
"out of %d with nonzero total read count
padj < %f
LFC > %f (up)    : %d
LFC < -%f (down) : %d",
        n_tot, 
        pvalueCutoff,
        lfcThreshold, n_up,
        lfcThreshold, n_down))
}

summary.res(res)
```

```{r annotation_noshrink}
# get annotation from biomart
ensembl = biomaRt::useMart("ensembl", dataset = "mmusculus_gene_ensembl")
annotation <- biomaRt::getBM(
        attributes = c("ensembl_transcript_id_version",
            "ensembl_gene_id_version", "mgi_symbol", "description",
            "gene_biotype", "transcript_length"), 
        filters = "ensembl_transcript_id_version", 
        values = res$ensembl_transcript_id_version, 
        mart = ensembl) %>% 
    as_tibble() %>% 
    distinct(ensembl_transcript_id_version, .keep_all = TRUE)

baseTPM <- rowMeans(tpm) %>% 
    tibble::enframe(name = "ensembl_transcript_id_version",
        value = "baseTPM")
```

```{r exportAnnotation_noshrink}
# merge annotation and TPM
res <- res %>% 
    left_join(annotation, by = "ensembl_transcript_id_version") %>% 
    left_join(baseTPM, by = "ensembl_transcript_id_version") %>% 
    select(ensembl_transcript_id_version, ensembl_gene_id_version, mgi_symbol, description, gene_biotype,
        baseMean, baseTPM, transcript_length, log2FoldChange,  lfcSE, pvalue, padj)

# export
res %>% 
    arrange(-abs(log2FoldChange)) %>% 
    write_csv(gzfile(file.path(res_folder, "txlevel_all_de_noshrink.csv.gz")))

# filter and kable
res_signif <- res %>% 
    filter(padj < .05) %>% 
    arrange(-abs(log2FoldChange))

res_signif %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling() %>%
    kableExtra::scroll_box(width = "100%", height = "600px")
```

### MA plot

```{r MA-plot_noshrink}
res %>%
    left_join(biotype_groups, by = "gene_biotype") %>% 
    mutate(signif = if_else(padj < .05, TRUE, FALSE)) %>%
    tidyr::drop_na() %>% 
    ggplot(aes(log10(baseMean), log2FoldChange)) +
        geom_point(aes(colour = signif, pch = grouped_biotype), size = 1.5) +
        geom_hline(yintercept = 0, colour = "blue") +
        scale_y_continuous(breaks = my_breaks(),
            labels = function(x) round(x, 1),
            name = "log2FoldChange ko vs het") +
        scale_x_continuous(breaks = log10(c(1,100,10000,max(res$baseMean))),
            labels = function(x) round(10^x),
            name = "baseMean") +
        scale_color_viridis_d(guide = FALSE)
```

### Clustering the significantly differentially expressed genes

```{r hclust_noshrink}
# filter significantly regulated genes
hclust_df <- assay(rld) %>%
    as_tibble(rownames = "gene") %>% 
    filter(gene %in% res_signif$ensembl_transcript_id_version) %>% 
    as.data.frame() %>%
    magrittr::set_rownames(.$gene) %>%
    dplyr::select(-gene) %>%
    (function(x) {x - rowMeans(x)})

# centering the colorscale
myColor <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
myBreaks <- c(seq(min(hclust_df), 0, length.out = ceiling(50) + 1),
    seq(max(hclust_df) / 100, max(hclust_df), length.out = floor(50)))

# plot heatmap
hclust <- pheatmap(hclust_df,
    fontfamily = "Palatino",
    annotation_col = colData(dds) %>%
         as.data.frame() %>%
         select(condition_temp),
    clustering_method = "ward.D2",
    clustering_distance_rows = "correlation",
    color = myColor, breaks = myBreaks,
    show_rownames = FALSE, show_colnames = TRUE,
    lwd = .2,
    cutree_rows = 2,
    border_color = NA)

hclust
```

### Gene ontology analysis

using TopGO

https://www.bioconductor.org/packages/release/bioc/html/topGO.html

reference: all expressed genes

```{r goAnalysis_noshrink}
# reference for the GO analysis are all expressed genes
all_genes <- res$ensembl_gene_id_version

# run the analysis
res_go <- res_signif %>%
    select(ensembl_gene_id_version, log2FoldChange) %>%
    mutate(regulation = if_else(log2FoldChange > 0 , "up", "down")) %>% 
        group_by(regulation) %>%
    tidyr::nest() %>%
    mutate(data = map(data, get.geneList)) %>%
    mutate(topGO = map2(data, as.character(regulation), make.topGO)) %>%
    mutate(res = map(topGO, get.results)) %>%
    mutate(n = map(data, function(x) sum(as.integer(as.character(x))))) %>%
    mutate(n = unlist(n))
```

#### Upregulated genes

```{r upGO_noshrink}
res_go$res[[1]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

#### Downregulated genes

```{r downGO_noshrink}
res_go$res[[2]] %>% 
    knitr::kable(format = "html") %>%
    kableExtra::kable_styling()
```

### Reactome

using ReactomePA

reference: all expressed genes

```{r reactome_noshrink}
# annotate with entrez ids
df_reactome <- res_signif %>% 
    pull(ensembl_gene_id_version) %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    left_join(res_signif, by = "ensembl_gene_id_version")
    
# named vector with lfc and entrez ids
geneList_reactome <- df_reactome$entrezgene_id
names(geneList_reactome) <- df_reactome$log2FoldChange

# reference are all expressed genes
all_genes_reactome <- res$ensembl_gene_id_version %>% 
    biomaRt::getBM(
        attributes = c("entrezgene_id", "ensembl_gene_id_version"), 
        filters = "ensembl_gene_id_version", 
        values = ., 
        mart = ensembl) %>% 
    pull(entrezgene_id) %>% 
    as.character()

# perform pathway analysis
res_reactome <- geneList_reactome %>% 
    enrichPathway(.,
        organism = "mouse",
        readable = TRUE,
        universe = all_genes_reactome)
```

```{r plot reactome_noshrink, fig.width = 12, fig.asp = 0.62}
if (nrow(res_reactome) == 0) {
    cat("ReactomePA did not find seignificant pathways.")
    } else {
    dotplot(res_reactome, 
        showCategory = 15)
    cnetplot(res_reactome, categorySize = "pvalue",
        foldChange = geneList_reactome)
}
```

# Session info

```{r sessionInfo}
sessionInfo()
```
